import { Connection, ConnectionPool } from "./connection";
import { EntityFromShape, getEntityFields, getEntityIndices } from "./entity";
import { logger } from "./logger";
import {
	SchemaCatalog,
	TableCatalog,
	TableColumnCatalog,
	TableIndexCatalog,
} from "./pgcatalog";
import { FinalizedQuery, sql } from "./queries";
import { createJoinQueryBuilder } from "./query-builder";

/**
 * Reason for why a migration is needed, as generated by the
 * [MigrationGenerator](/reference/types/migration-generator).
 */
export type MigrationReason =
	| "Missing Schema"
	| "Missing Table"
	| "Missing Index"
	| "Unused Index"
	| "New Index"
	| "Index Updated"
	| "Index Renamed"
	| "Unused Column"
	| "New Column"
	| "Column Default Updated"
	| "Column Type Updated"
	| "Column Renamed";

/**
 * A set of migration queries, with a reason for why they are needed,
 * as generated by the [MigrationGenerator](/reference/types/migration-generator).
 */
export interface SuggestedMigration {
	reason: MigrationReason;
	queries: FinalizedQuery[];
}

/**
 * Utility class that generates migrations for a given entity.
 */
export class MigrationGenerator {
	constructor(readonly connection: Connection) {}

	async getMigrationQueries(
		entity: EntityFromShape<unknown>,
	): Promise<SuggestedMigration[]> {
		const migrationQueries: SuggestedMigration[] = [
			...(await this.getSchemaMigration(entity.schema)),
		];

		// Creation of table from scratch
		const tableInfo = await createJoinQueryBuilder()
			.from(TableCatalog, "table_entry")
			.selectAll("table_entry")
			.addWhere((where) =>
				where("table_entry", "table_schema")
					.Equals(entity.schema)
					.andWhere("table_entry", "table_name")
					.Equals(entity.tableName),
			)
			.getOne(this.connection);
		if (!tableInfo) {
			return [
				...migrationQueries,
				...(await this.getTableInitMigration(entity)),
			];
		}

		// Identify table changes
		migrationQueries.push(...(await this.getTableIndicesMigrations(entity)));
		migrationQueries.push(...(await this.getTableColumnMigrations(entity)));

		return migrationQueries;
	}

	async getSchemaMigration(schemaName: string) {
		const migrationQueries: SuggestedMigration[] = [];

		const schemaInfo = await createJoinQueryBuilder()
			.from(SchemaCatalog, "schema_entry")
			.selectAll("schema_entry")
			.addWhere((where) =>
				where("schema_entry", "schema_name").Equals(schemaName),
			)
			.getOne(this.connection);

		// Creation of schema
		if (!schemaInfo) {
			migrationQueries.push({
				reason: "Missing Schema",
				queries: [
					sql.finalize(
						sql`CREATE SCHEMA IF NOT EXISTS "${sql.asUnescaped(schemaName)}"`,
					),
				],
			});
		}

		return migrationQueries;
	}

	async getTableInitMigration(entity: EntityFromShape<unknown>) {
		const migrationQueries: SuggestedMigration[] = [];

		migrationQueries.push({
			reason: "Missing Table",
			queries: [
				sql.finalize(ConnectionPool.getCreateTableQuery(entity, false)),
			],
		});

		for (const { query } of getEntityIndices(entity).values()) {
			migrationQueries.push({
				reason: "Missing Index",
				queries: [query],
			});
		}

		return migrationQueries;
	}

	async getTableIndicesMigrations(entity: EntityFromShape<unknown>) {
		const migrationQueries: SuggestedMigration[] = [];
		const indexSet = getEntityIndices(entity);

		const existingIndexData = await createJoinQueryBuilder()
			.from(TableIndexCatalog, "index_entry")
			.selectAll("index_entry")
			.addWhere((where) =>
				where("index_entry", "schemaname")
					.Equals(entity.schema)
					.andWhere("index_entry", "tablename")
					.Equals(entity.tableName),
			)
			.getMany(this.connection);
		const validExistingIndexNames = new Set<string>();

		for (const [indexName, indexOptions] of indexSet.entries()) {
			const existingIndex = existingIndexData.find(
				(row) =>
					row.index_entry.indexname === indexName ||
					row.index_entry.indexname === indexOptions.previousName,
			);

			if (existingIndex) {
				validExistingIndexNames.add(existingIndex.index_entry.indexname);

				if (existingIndex.index_entry.indexname !== indexName) {
					// Indices that need to be renamed
					migrationQueries.push({
						reason: "Index Renamed",
						queries: [
							sql.finalize(
								sql`ALTER INDEX "${sql.asUnescaped(
									entity.schema,
								)}"."${sql.asUnescaped(
									existingIndex.index_entry.indexname,
								)}" RENAME TO "${sql.asUnescaped(indexName)}"`,
							),
						],
					});
				}

				// Indices that had their criteria changed
				if (existingIndex.index_entry.indexdef !== indexOptions.query.text) {
					migrationQueries.push({
						reason: "Index Updated",
						queries: [
							sql.finalize(
								sql`DROP INDEX IF EXISTS "${sql.asUnescaped(
									entity.schema,
								)}"."${sql.asUnescaped(indexName)}"`,
							),
							indexOptions.query,
						],
					});
				}
			} else {
				// Indices that need to be created
				migrationQueries.push({
					reason: "New Index",
					queries: [indexOptions.query],
				});
			}
		}

		// Indices that need to be dropped
		for (const existingIndex of existingIndexData) {
			if (!validExistingIndexNames.has(existingIndex.index_entry.indexname)) {
				migrationQueries.push({
					reason: "Unused Index",
					queries: [
						sql.finalize(
							sql`DROP INDEX IF EXISTS "${sql.asUnescaped(
								entity.schema,
							)}"."${sql.asUnescaped(existingIndex.index_entry.indexname)}"`,
						),
					],
				});
			}
		}

		return migrationQueries;
	}

	async getTableColumnMigrations(entity: EntityFromShape<unknown>) {
		const migrations: SuggestedMigration[] = [];

		const columnSet = getEntityFields(entity);
		const existingColumnData = await createJoinQueryBuilder()
			.from(TableColumnCatalog, "col")
			.selectAll("col")
			.addWhere((where) =>
				where("col", "table_schema")
					.Equals(entity.schema)
					.andWhere("col", "table_name")
					.Equals(entity.tableName),
			)
			.getMany(this.connection);

		const validExistingColumnNames = new Set<string>();

		for (const [columnName, columnOptions] of columnSet.entries()) {
			const existingColumns = existingColumnData.filter(
				(column) =>
					column.col.column_name === columnName ||
					column.col.column_name === columnOptions.previousName,
			);
			if (existingColumns.length > 1) {
				throw new Error(
					`Multiple existing columns matched the description for ${
						entity.tableName
					}.${columnName}: ${JSON.stringify(
						existingColumns.map((col) => col.col.column_name),
					)}`,
				);
			}

			const matchingStoredColumn = existingColumns[0]?.col;
			if (matchingStoredColumn) {
				validExistingColumnNames.add(matchingStoredColumn.column_name);

				// Columns that need to be renamed
				if (matchingStoredColumn.column_name !== columnName) {
					migrations.push({
						reason: "Column Renamed",
						queries: [
							sql.finalize(
								sql`ALTER TABLE "${sql.asUnescaped(
									entity.schema,
								)}"."${sql.asUnescaped(
									entity.tableName,
								)}" RENAME COLUMN "${sql.asUnescaped(
									matchingStoredColumn.column_name,
								)}" TO "${sql.asUnescaped(columnName)}"`,
							),
						],
					});
				}

				// Columns that don't have a default value anymore
				if (
					matchingStoredColumn.column_default &&
					!columnOptions.defaultValue
				) {
					migrations.push({
						reason: "Column Default Updated",
						queries: [
							sql.finalize(
								sql`ALTER TABLE "${sql.asUnescaped(
									entity.schema,
								)}"."${sql.asUnescaped(
									entity.tableName,
								)}" ALTER COLUMN "${sql.asUnescaped(
									matchingStoredColumn.column_name,
								)}" DROP DEFAULT`,
							),
						],
					});
				}

				// Columns that changed their default values
				else if (
					columnOptions.defaultValue &&
					matchingStoredColumn.column_default !==
						columnOptions.defaultValue?.text.join("")
				) {
					migrations.push({
						reason: "Column Default Updated",
						queries: [
							sql.finalize(
								sql`ALTER TABLE "${sql.asUnescaped(
									entity.schema,
								)}"."${sql.asUnescaped(
									entity.tableName,
								)}" ALTER COLUMN "${sql.asUnescaped(
									matchingStoredColumn.column_name,
								)}" SET DEFAULT ${columnOptions.defaultValue}`,
							),
						],
					});
				}

				// Columns that changed their types
				if (matchingStoredColumn.data_type !== columnOptions.type) {
					migrations.push({
						reason: "Column Type Updated",
						queries: [
							sql.finalize(
								sql`ALTER TABLE "${sql.asUnescaped(
									entity.schema,
								)}"."${sql.asUnescaped(
									entity.tableName,
								)}" ALTER COLUMN "${sql.asUnescaped(
									matchingStoredColumn.column_name,
								)}" TYPE ${sql.asUnescaped(columnOptions.type)}`,
							),
						],
					});
				}
			}
		}

		// Columns that need to be dropped
		for (const existingColumn of existingColumnData) {
			if (!validExistingColumnNames.has(existingColumn.col.column_name)) {
				migrations.push({
					reason: "Unused Column",
					queries: [
						sql.finalize(
							sql`ALTER TABLE "${sql.asUnescaped(
								entity.schema,
							)}"."${sql.asUnescaped(
								entity.tableName,
							)}" DROP COLUMN "${sql.asUnescaped(
								existingColumn.col.column_name,
							)}"`,
						),
					],
				});
			}
		}

		return migrations;
	}
}

/**
 * Interface that defines a migration for [runMigrations](/reference/functions/run-migrations) to run.
 */
export interface Migration {
	name: string;
	createdAt: string;
	queries: (FinalizedQuery | SuggestedMigration)[];
}

/**
 * Runs a set of migrations, and fails if any of them fail. Each migration is run in its own
 * transaction and possibly its own client.
 *
 * @param pool a connection pool to run the migrations on
 * @param migrations set of migrations to run
 */
export async function runMigrations(
	pool: ConnectionPool,
	migrations: Migration[],
) {
	if (migrations.length === 0) {
		return;
	}

	const sortedMigrations = [...migrations].sort((left, right) =>
		left.createdAt.localeCompare(right.createdAt),
	);

	logger.info(`Initializing migrations table`);
	await pool.withTransaction(async (connection) => {
		await connection.initMigrations();
	});
	logger.info(`Ready to run migrations`);

	for (const migration of sortedMigrations) {
		logger.info(
			{ migrationName: migration.name, createdAt: migration.createdAt },
			`Starting migration`,
		);
		await pool.withTransaction(async (connection) => {
			await connection.executeMigration(migration.name, migration.queries);
		});
		logger.info(
			{ migrationName: migration.name },
			`Migration completed successfully`,
		);
	}
}
